# 总结

现在，你已经拥有了七巧板的每一块：了解了重构的基础，知道了重构的分类，还实践了所有这些重构。
同时，你已经很擅⻓测试了，所以不再畏⾸畏尾。于是你可能想：“我已经知道如何重构了。” 
不，还没有。

前⾯列出的技术仅仅是⼀个起点，是你登堂⼊室之前的⼤⻔。
如果没有这些技术，你根本⽆法对运⾏中的程序进⾏任何设计上的改动。
有了这些技术，你仍然做不到，但起码可以开始尝试了。

这些技术如此精彩，可它们却仅仅是个开始，这是为什么？
答案很简单：因为你还不知道
何时应该使⽤它们、何时不应该使⽤；
何时开始、何时停⽌；
何时前进、何时等待。
使重构能够成功的，不是前⾯各⾃独⽴的技术，⽽是这种节奏。

你⼜是如何得知什么时候才真正懂得这⼀切的呢？
正是当你开始冷静下来的时候，对⾃⼰的重构技艺感到绝对⾃信
————不论别⼈留下的代码多么杂乱⽆章，你都可以将它变好，好到⾜以进⾏后续的开发
————那时你就知道，⾃⼰已经“得道”了。

不过，⼤多数时候，“得道”的标志是：你可以⾃信地停⽌重构。
在重构者的整场表演中，“停⽌”正是压轴⼤戏。
⼀开始，你为⾃⼰选择⼀个⼤⽬标，例如 “去掉⼀堆不必要的⼦类”。
然后，你开始向着这个⽬标前进，每⼀步都⾛得⼩⽽坚定，每⼀步都有备份，保证能够回头。
好的，你离⽬标愈来愈近，愈来愈近，现在只剩两个函数需要合并，然后就将⼤功告成。

就在此时，意想不到的事情发⽣了：你再也⽆法前进⼀步。
也许是因为，时间太晚，你太疲倦；
也许是因为，⼀开始你的判断就出错，实际上不可能去掉所有⼦类； 
也许是因为，没有⾜够的测试来⽀持你。
总⽽⾔之，你的⾃信灰⻜烟灭，你⽆法再⾃信满满地跨出下⼀步。
你认为⾃⼰应该没把任何东⻄搞乱，但也⽆法确定。

这是该停下来的时候了。
如果代码已经⽐重构之前好，那么就把它集成到系统中，发布你的成果。
如果代码并没有变好，就果断放弃这些⽆⽤的⼯作，回到起始点。 
然后，为⾃⼰学到⼀课⽽⾼兴，为这次重构没能成功⽽抱憾。
那么，明天怎么办？

明天，或者后天，或者下个⽉，甚⾄可能是明年，灵感总会来的。
为了等待进⾏⼀项重构的后⼀半所需的灵感，我最多曾经等过九个⽉。
你可能会明⽩⾃⼰错在哪⾥，也可能明⽩⾃⼰对在哪⾥，总之，都能使你想消楚下⼀个步骤如何进⾏。
然后，你就可以像最初⼀样⾃信地跨出这⼀步。
也许你羞愧地想：“我太笨了，竟然这么久都没想到这⼀步。”
⼤可不必，每个⼈都是这样的。

这有点像在悬崖峭壁上的⼩径⾏⾛：只要有光，你就可以前进，虽然谨慎却仍然⾃信。
但是，⼀旦太阳下⼭，你就应该停⽌前进；
夜晚你应该睡觉，并且相信，明天早晨 太阳仍旧升起。

这听起来似乎有点神秘⽽模糊，近乎清谈⽞想。
从感觉上来说，的确如此，因为这是⼀种全新的编程⽅式。
当你真正理解重构之后，系统的整个设计对你来说，就像 源码⽂件中的字符 那样，可以随⼼所欲地操控。
你可以直接感受到整个设计，可以清楚看到如何将设计变得更灵活，也可以看到如何修改它：
这⾥修改⼀点，于是这样表现；
那⾥修改⼀点，于是那样表现。

但是，从另⼀个⻆度来说，这也并⾮那么地神秘⽽模糊。
重构是⼀种可以学习的技术，你可以从本书读得并学习它的各个组成。
然后，只要把这些技术集成在⼀起并使之完善，就可以从⼀个全新⻆度看待软件开发。

正如我所说，这是⼀种可以学习的技术。
那么，应该如何学习呢？
⼝ 随时挑⼀个⽬标。
某个地⽅的代码开始发臭了，你就应该将问题解决掉。
你应该⽬标前进，达成⽬标后就停⽌。
你之所以重构，不是为了探索 真善美（⾄少不全是），⽽是为了让你的系统更容易被⼈理解，为了防⽌程序变得散乱。

⼝ 没把握就停下来。
朝⽬标前进的过程中，可能会有这样的时候：你⽆法证明⾃⼰所做的⼀切能够保持程序原本的语义。
此时，你就应该停下来。如果代码已经改善了⼀些，就发布你的成果；如果没有，就撤销所有修改。

⼝ 学习原路返回。
重构的原则不好学，⽽且很容易遗失准头。
就连我⾃⼰，也经常忘记这些原则。
我有时会连续做两、三项甚⾄四项重构，⽽没有每次执⾏测试⽤例。
当然，那是因为我完全相信，即使没有测试的帮助，我也不会出错。
于是我就放⼿⼲了。
然后，“砰”的⼀声，某个测试失败，我却⽆法找到究竟哪⼀次修改造成了这个问题。

这时候，你⼀定很愿意就地调试，试图从⿇烦中脱⾝。
毕竟，不管怎么说，⼀开始所有测试都能够正常运⾏，现在要让它们再次正常运⾏，会困难到哪⾥去？
停！你的重构已经失控了，如果继续向前⾛，你根本不可能知道如何夺回控制权。
你应该回到最近⼀个没有出错的状态，然后逐⼀重复刚才做过的重构项，每次重构之后⼀定要运⾏所有测试。

站着说话不腰疼，以上⼀切听起来似乎显⽽易⻅。
当你出错的时候，使系统极⼤简化的⼀个⽅案也许已经近在咫尺，这时候要你停下来回到起点，不啻是最痛苦的事情。
但是，现在，趁你头脑还清楚的时候，请想⼀想：
如果，你第⼀次重构⽤了⼀⼩时，重复它，只需⼗分钟就够了，
所以，如果你退回原点，⼗分钟之内⼀定能够再次达到现在的进度。
但，如果你继续前进，调试所需时间也许是五秒种，也许是两⼩时。

当然，我现在说这些，也是看⼈挑担不吃⼒，实际做起来困难得多。
我个⼈曾经因为没有遵循这条建议，花了四个⼩时进⾏三次尝试。
我失控、放弃、慢慢前进、再次失控、再重复。。。。。真是痛苦的四个⼩时。
这不是件有趣的事，所以你需要帮助。

⼝ ⼆重奏。
和别⼈⼀起重构，可以收到更好的效果。两⼈结对，对于任何⼀种 软件开发都有很多好处，对于重构也不例外。
重构时，**⼩⼼谨慎、按部就班的态度**是有好处的。
如果两⼈结伴，你的搭档能够帮助你⼀步⼀步前进，你也能够帮助他。

重构时，**时刻留意远景⽬标**是有好处的。
如果两⼈结伴，你的搭档可能看到你没看到的东⻄，能想到你没想到的事情。

重构时，**明智结束**是有好处的。
如果你的搭档不知道你在⼲什么，那就意味你肯定也不知道⾃⼰在干什么，此时你就应该结束重构。
最重要的是，重构时，拥有绝对⾃信是绝对有好处的。
如果两⼈结伴，你的搭档能够给你温柔的⿎励，让你不 ⾄于灰⼼丧⽓。

与搭档协同⼯作的另⼀⽅⾯就是交谈。
你必须讲出你所想做的事，这样你们两个才能朝着同⼀个⽅向努⼒。
你得把你正在做的事情讲出来，这样你的搭档才有可能指出你的错误。
你得把刚才做过的事情讲出来，这样下次遇到同样情况时你才能做得更好。
所有这些交谈，都有助于你更清楚了解，如何让个别的重构项，适应整个重构节奏。

即使，你⼰经在你的重构⽬标（代码）中⼯作了好⼏年，⼀丝⼀缕了然于胸，
但只要发现其中的坏味道，以及消除坏味道的重构⼿法，你就有可能看到程序的另⼀种可能。
你也许会想⽴刻挽起袖⼦，把你看到的所有问题都解决掉。
不，不要这么莽撞。
没有⼀位经理愿意听到他的开发成员说 “我们要停⼯三个⽉，来清理以前的代码”。
⽽且开发⼈员本来也就不应该这样做。
⼤规模的重构只会带来灾难。

你⾯前的代码也许看起来混乱极了，不要着急，⼀点⼀点慢慢地解决这些问题。 
当你想要添加新功能时，⽤上⼏分钟时间把代码整理⼀下。
如果，⾸先添加⼀些测试，能使你对整理⼯作更有信⼼，那就去做，它们会回报你的努⼒。
如果，在添加新代码之前进⾏重构，那么添加新代码的⻛险将⼤⼤降低。
重构，可以使你更好理解 代码的作⽤ 和 ⼯作⽅式，这使得 新功能的添加 更容易。
⽽且，重构之后，代码的质量也会⼤⼤提⾼，下次你再有机会处理它们的时候，肯定会对⽬前所做的重构感到⾮常满意。

永远不要忘记“两顶帽⼦”。
重构时，你总会发现某些代码并不正确。
你绝对相信⾃⼰的判断，因此想⻢上把它们改正过来。
啊，顶住诱惑，别那么做。
重构时，你的⽬标之⼀就是：保持代码的功能完全不变，既不多也不少。
对于那些需要修改的东⻄，列个清单把它们记录下来（通常我在计算机旁边放⼀张索引卡），
需要 添加 或 修改 的 测试⽤例、
需要 进⾏的其他重构、
需要 撰写的⽂档、
需要 画的图。。。。。都暂时记在卡上。
这样，就不会忘掉这些需要完成的⼯作。
千万别让这些⼯作打乱你⼿上的⼯作。 
重构完成之后，再去做这些事情也不迟。