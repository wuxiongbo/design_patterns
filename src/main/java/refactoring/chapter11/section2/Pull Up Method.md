# 函数上移

有些函数，在各个⼦类中产⽣完全相同的结果。 

将该函数移⾄超类。
```puml
class Employee{}
    
class Salesman extends Employee{
    String getName();
}

class Engineer extends Employee{
    String getName();
}
```

```puml
class Employee {
    String getName();
}
    
class Salesman extends Employee{}
class Engineer extends Employee{}
```

## 动机

避免⾏为重复是很重要的。  
尽管重复的两个函数也可以各⾃⼯作得很好，但重复⾃身，只会成为错误的滋⽣地，此外，别⽆价值。

⽆论何时，只要系统之内出现重复，你就会⾯临 “修改其中⼀个却未能修改另⼀个” 的⻛险。

通常，找出重复也有⼀定困难。
如果某个函数在各⼦类中的函数体都相同（它们很可能是通过复制粘贴得到的），这就是最显⽽易⻅的 Pull Up Method （322）适⽤场合。
当然，情况并不总是如此明显。
你也可以只管放⼼地重构，再看看测试程序会不会发牢骚，但，这就需要对你的测试有充分的信⼼。
我发现，观察这些 可能重复的函数之间的差异，往往⼤有收获：它们经常会向我展⽰那些我忘记测试的⾏为。

Pull Up Method（322），常常紧随其他重构⽽被使⽤。
也许，你能找出若⼲个 ⾝处不同⼦类内的函数，⽽它们 又可以通过某种形式的参数，调整成为相同的函数。
这时候，最简单的办法就是，⾸先，分别调整这些函数的参数，然后，再将它们概括到超类中。
当然，如果你⾜够⾃信，也可以⼀次完成这两个步骤。

有⼀种特殊情况也需要使⽤ Pull Up Method（322）： ⼦类的函数 覆写了 超类的函数，但却仍然做相同的⼯作。

Pull Up Method（322）过程中，最麻烦的⼀点就是：被提升的函数 可能会 引⽤ 只出现于⼦类 ⽽ 不出现于超类 的方法或变量。
如果被引⽤的是个函数，你可以将 该函数 也⼀同提升到 超类，或者 在 超类中 建⽴⼀个 抽象函数。
在此过程中，你可能需要修改某个函数的签名，或建⽴⼀个委托函数。

如果两个函数 相似但不相同，你或许可以先借助 Form Template Method（345）构造出相同的函数，然后，再提升它们。


## 做法

-[ ] 检查待提升函数，确定它们是完全⼀致的。 
>-如果这些函数看上去做了相同的事，但并不完全⼀致，可使⽤ Substitute Algorithm（139）让它们变得完全⼀致.
-[ ] 如果待提升函数的签名不同，将那些签名都修改为你想要在超类中使⽤的签名。
-[ ] 在超类中新建⼀个函数，将某⼀个待提升函数的代码复制到其中，做适当调整，然后编译。
>-如果，你使⽤的是⼀种强类型语⾔，⽽待提升函数⼜调⽤了⼀个只出现于⼦类⽽未出现于超类的函数，你可以在超类中，为被调⽤函数声明⼀个抽象函数.
>-如果，待提升函数使⽤了⼦类的⼀个字段，你可以使⽤ Pull Up Field（320），将该字段也提升到超类； 
  或者，也可以先使⽤ Self Encapsulate Field（171），然后，在超类中把 取值函数 声明为 抽象函数。
-[ ] 移除⼀个待提升的⼦类函数。 
-[ ] 编译，测试。 
-[ ] 逐⼀移除待提升的⼦类函数，直到只剩下超类中的函数为⽌。每次移除之后都需要测试。
-[ ] 观察该函数的调⽤者，看看是否可以改为使⽤超类类型的对象。

