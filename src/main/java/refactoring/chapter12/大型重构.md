# ⼤型重构
     -Kent Beck和Martin Fowler

前面的章节已经向读者展示了各个单项重构的步骤，但读者恐怕还是只见树木不见森林。
你之所以进行重构，必定是为了达到某个目的，而不仅仅是为了看起来有所动作（起码⼤多数时候你的重构是为了达到某个⽬的）。
那么， 这整个游戏究竟是怎么玩的呢？


## 这场游戏的特点

以下介绍的重构⼿法中，你肯定会注意到⼀件事：重构步骤的描述，不再如前 ⾯那么仔细。
这是因为在⼤型璽构中，情况有很乡变化，我们⽆法告诉你准确的重构步骤。
如果没有看到实际情况，任谁都⽆法确切知道该怎么做。当你为某个函数添加参数时，做法可以很仔细⽽清楚，因为重构范围很清楚；
但是当你分解⼀个继承体系时，由于每个继承体系都是不同的，所以我们⽆法告诉你确切的重构步骤。

另外，对于这些⼤型重构，还有⼀件事需要注意：它们会耗费相当⻓的时间。 第6~11章所介绍的重构⼿法，都可以在⼏分钟（⾄多⼀个⼩时）内完成：
但是我们曾经进⾏过的⼀些⼤型重构，却需要数⽉甚⾄数年的时间。
如果你需要给⼀个运⾏中的系统添加功能，你不可能说服经理把系统停⽌运⾏两个⽉让你进⾏重构。
你只能⼀点⼀点地做你的⼯作，今天⼀点点，明天⼀点点。

在这个过程中，你应该根据需要安排⾃⼰的⼯作，只在需要添加新功能或修补错误时才进⾏重构。
你不必⼀开始就完成整个系统的重构，重构程度只要能满⾜其他任务的需要就⾏了。反正明天你还可以回来重构。

本章范例也反映出这样的哲学。如果要向你展示本书中所有的重构，轻易就能耗去上百⻚篇幅。
我们很消楚这⼀点，因为Martin的确尝试过。所以，我们把范例 压缩⾄⼏张概略图的尺度。

由于⼤型重构可能需要花费相当长的时间，因此它们并不像其他章节介绍的重构那样，能够⽴刻让⼈满意。
你必须有那么⼀点⼩⼩的信仰：你每天都在使你⾃⼰ 的程序世界更安全。

进⾏⼤规模重构时，有必要为整个开发团队建⽴共识，这是⼩型重构所不需要的。
⼤型重构为许许多多的修改指定了⽅向。
整个团队都必须意识到：有⼀个⼤型重构正在进⾏，每个⼈都应该相应地安排⾃⼰的⾏动。
说到这⾥，我想给⼤家讲个故事。
两个家伙的⻋⼦在⼭项附近抛锚了，于是他俩⾛下⻋，⼀⼈⾛到⻋的⼀头， 开始推⻋。
经过毫⽆成果的半⼩时之后，⻋头那家伙开⼝说道：“我从来不知道把⻋推下⼭这么难！”
另⼀个家伙答道：“嘿，你说‘推下⼭’是什么意思？难道我们不是想把⻋推上⼭吗？” 我猜你⼀定不想让这个故事在你的开发团队中重演，对吧！


## ⼤型重构的重要性

我们已经看到，使那些⼩型重构突显价值的质量（可预测的结果、可观察的过程、⽴竿⻅影的满⾜等等），在⼤型重构中往往并不存在。
既然如此，为什么⼤型重构还那么重要，以⾄于我们想要把它们放进本书？
那是因为如果没有它们，我们就可能⾯临这样的⻛险：投⼊了⼤把时间学习重构，在实际⼯作中却⽆法获得实在的利益。
这对我们来说是⾮常糟糕的，我们不能容忍这种事情发⽣。

更重要的是，你之所以需要重构，决不会是因为它很好玩，⽽是因为你希望它能对你的程序有所帮助，让你能够做⼀些重构之前⽆法做的事情。

正如⽔草会堵塞河道⼀样，在⼀知半解的情况下做出的设计决策，⼀旦堆积起来，也会使你的程序陷于瘫痪。
通过重构，你可以保证随时在程序中反映出完整的设计思路。正如⽔草会迅速蔓延⼀样，对系统理解不够完整的设计决策，也会很快地将它们的影响蔓延到整个程序中。
要根除这种错误，⼀个、两个，甚⾄⼗个单独的⾏为都是不够的，只有持续⽽⽆处不在的重构才有可能竟其功。 

## 四个⼤型重构

本章之中，我们将介绍四个⼤型重构实例。
这些仅仅是例⼦，我们并没有打算覆盖所有领域。
迄今为⽌，绝⼤多数关于重构的研究和实践都集中于⽐较⼩的重构⼿法上，以这种⽅式谈论⼤型重构，是⼀种⾮常新鲜的做法，这主要来⾃于Kent的经验。
在⼤规模重构⽅⾯，Kent的经验⽐其他所有⼈都要丰富。 

Tease Apart Inheritance （362）⽤于处理混乱的继承体系——这种继承体系往往以⼀种令⼈迷惑的⽅式组合了多个不同⽅⾯的变化。
Convert Procedural Design 10 Objects（368）可以帮助你解决⼀个经典问题：如何处理过程式代码？
许多使⽤⾯向对象语⾔的程序员，其实并没有真正理解⾯向对象技术，因此你常会需要使⽤这项重构。
如果你看到以传统的两层结构（two-tier，⽤户界⾯和数据库）⽅式编写的代码，
你可能需要使⽤ Separate Domain from Presentation （370）将业务逻辑与⽤户界⾯隔离开来。
经验丰富的⾯向对象开发⼈员发现：对于⼀个⻓时间、⼤负荷运转的系统来说，这样的分离是⾄关重要的。
Extract Hierarchy （375）则可以将过于复杂的类转变为⼀群⼦类，从⽽简化系统。