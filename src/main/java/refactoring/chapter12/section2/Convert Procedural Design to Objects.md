Convert Procedural Design to Objects （将过程化设计转化为对象设计）

你⼿上有⼀些传统过程化⻛格的代码。 

将数据记录变成对象，将⼤块的⾏为分成⼩块， 并将⾏为移⼊相关对象之中。

```puml

```


## 动机

有⼀次，我们的⼀位客户在项⽬开始时给开发者提出了两条必须遵守的条件：
（1） 必须使⽤Java：（2）不能使⽤对象。

这故事固然好笑。
不过，尽管Java是⾯向对象语⾔，“使⽤对象”可远不仅仅是 调⽤ 构造函数 ⽽已。
对象的使⽤也需要花时间去学习。
往往你会⾯对⼀些过程化⻛格的代码所带来的问题，并因⽽希望它们变得更⾯向对象⼀些。

典型的情况是：类中有着 ⻓⻓的过程化函数 和 极少的数据，旁边则是⼀堆 哑数据对象 ——除了 数据访问函数 外，没有其他任何函数。
如果你要转换的是⼀个纯粹的过程化程序，可能连这些东⻄都没有。 

我们并不是说，绝对不应该出现只有⾏为⽽⼏乎没有数据的对象。
在 Strategy模式 中，我们常常使⽤⼀些 ⼩型的策略对象，来改变宿主对象的⾏为，这些⼩型的策略对象就 只有⾏为 ⽽ 没有数据。
但是，这样的对象通常⽐较⼩，⽽且只有在我们特别需要灵活性的时候，才会使⽤它们。

## 做法
⼝ 针对每⼀个记录类型，将其转变为只含访问函数的哑数据对象。 
• 如果你的数据来⾃关系式數据库，就把數据库中的每个表变成⼀个哑数据对象.

⼝ 针对每⼀处过程化⻛格，将该处的代码提炼到⼀个独⽴类中。 
•你可以把提炼所得的类做成⼀个Singleton（为了⽅便重新初始化），或是把提炼所得的函数声明为static。 
⼝ 针对每⼀段⻓⻓的程序，实施 Exiract Method（110）及其他相关重构将它分解。 
再以Move Method （142）将分解后的函数分别移到它所相关的哑数据类中。

⼝ 重复上述步骤，直到原始类中的所有函数都被移除。
如果，原始类 是⼀个 完全过程化的类，将它拿掉将⼤快⼈⼼。

## 范例

第1章的范例很好地展示了 Convert Procedural Design to Objects （368），尤其是第⼀阶段（对statement（）函数的分解和安置）。
完成这项重构之后，你就拥有了⼀个“聪明的” 数据对象，可以对它进⾏其他重构了。

