# Extract Hierarchy（提炼继承体系）

你有某个类做了太多⼯作，其中⼀部分⼯作是以⼤量条件表达式完成的。 

建⽴继承体系，以⼀个⼦类表示⼀种特殊情况。


## 动机

在渐进式设计过程中，常常会有这样的情况：
⼀开始，设计者只想以⼀个类实现⼀个概念；
但随着设计⽅案的演化，最后却可能⼀个类实现了两个、三个乃⾄⼗个不同的概念。

⼀开始，你建⽴了这个简单的类。
数天或数周之后，你可能发现：
只要加⼊⼀个标记和⼀两个测试，就可以在另⼀个环境下使⽤这个类：
⼀个⽉之后你⼜发现了另⼀个这样的机会；
⼀年之后，这个类就完全⼀团糟了：标记变量和条件表达式遍布各处。

当你遇到这种瑞⼠军⼑般的类—不但能够开瓶开罐、砍⼩树枝、还能在演示会上打出激光强调重点——你就需要⼀个好策略（亦即本项重构），
将它的各个功能梳理并分开。
不过，请注意，只有当 条件逻辑 在 对象的整个⽣命周期 保持不变，本重构所导⼊的策略才适⽤。
否则，你可能必须在分离各种状况之前先使⽤ Extract Class 

Extract Hierarchy （375）是⼀项⼤型重构，如果你⼀天之内不⾜以完成它，不要因此失去勇⽓。
将⼀个极度混乱的设计⽅案梳理出来，可能需要数周甚⾄数⽉的时间。
你可以先进⾏本重构中的⼀些简易步骤，稍微休息⼀下，再花⼏天时间编写⼀ 些能体现产出的代码。
当你领悟到更多东⻄，再回来继续本项重构的其他步骤——这些步骤将因为你的领悟⽽显得更加简单明了。

## 做法

我们为你准备了两组重构做法。
第⼀种情况是： 
你⽆法确定哪些地⽅会发⽣变化。这时候你会希望每次⼀⼩步地前进。

⼝ 鉴别出⼀种变化情况。
•如果这种变化可能在对象⽣命周期的不同阶段⽽有不同体现，就运⽤ Extract Class （149）将它提炼为⼀个独⽴的类。

⼝ 针对这种变化情况，新建⼀个⼦类，并对原始类实施Replace Constructor with Factory Method （304）。
   再修改⼯⼚函数，令它返回适当的⼦类实例。

⼝ 将含有条件逻辑的函数，⼀次⼀个，逐⼀复制到⼦类，然后在明确情况下（对 ⼦类明确，对超类不明确），简化这些函数。
•如有必要隔离函数中的条件逻辑和⾮条件逻辑，可对超类实施Extract Merhod （110）.

⼝ 重复上述过程，将所有变化情况都分离出来，直到可以将超类声明为抽象类为⽌。

⼝ 删除超类中那些被所有⼦类覆写的函数本体，并将它们声明为抽象函数。 
如果你⾮常清楚原始类会有哪些变化情况，可以使⽤另⼀种做法。 

⼝ 针对原始类的每⼀种变化情况，建⽴⼀个⼦类。

⼝ 使⽤Replace Constructor with Factory Method （304）将原始类的构造函数转变成⼯⼚函数，并令它针对每⼀种变化情况返回适当的⼦类实例。
• 如果原始类中的各种变化情况是以类型码标示，先使⽤Replace Type Code with Subclasses （223）；
如果那些变化情况在对象⽣命周期的不同阶段会有不同体现，请使⽤ Replace Type Code with State/Strategy（227）. 

⼝ 针对带有条件逻辑的函数，实施 Replace Conditional with Polymorphism （255）。
如果并⾮整个函数的⾏为有所变化，⽽只是函数⼀部分有所变化，请先运⽤ Extract Method（110）将 变化部分 和 不变部分 隔开来。

## 范例

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
这⾥所举的例⼦是变化情况并不明朗的情况。
你可以在 
Replace Type Code with Subclasses （223）、
Replace Type Code with State/Strategy （227）和 
Replace Conditional with Polymorphism （255）等重构结果之上，
验证在变化情况已经明朗的情况下如何使⽤本项重构。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
我们以⼀个电费计算程序为例。
这个程序有两个类：
表示“消费者”的customer 和 
表示“计费⽅案”的 BillingScheme ，如图12-11。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
BillingScheme 使⽤⼤量条件逻辑来计算不同情况下的费⽤：
冬季和夏季的电价不同，
私宅⽤电、⼩型企业⽤电、社会救济（包括残障⼈⼠）⽤电的价格也不同。 
这些复杂的逻辑导致 BillingScheme 变得复杂。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
第⼀个步骤是，提炼出条件逻辑中经常出现的某种变异性。
本例之中可能是“视⽤户是否为残障⼈⼠”⽽发⽣的变化。
⽤于标示这种情况的可能是 Customer、 BillingScheme 或其他地⽅的⼀个标记变量（flag）。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
我们针对这种变异建⽴⼀个⼦类。
为了使⽤这个⼦类，我们需要确保它被建⽴并且被使⽤。
因此我们需要处理Bi1lingScheme构造函数：
⾸先，对它实施 Replace Constructor with Factory Method （304），
然后，在所得的⼯⼚函数中为残障⼈⼠增加⼀个条件⼦句，使它在适当时候返回⼀个 DisabilityBillingScheme 对象。 

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
然后，我们需要观察 BillingScheme 的其他函数，寻找那些随着⽤户是否为残 障⼈⼠⽽变化的⾏为。
CreateBill()就是这样⼀个函数，因此，我们将它复制到⼦类（图12-12）。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
现在，我们需要检查⼦类中的createBi11（）函数。
由于现在我们可以肯定该 消费者是残障⼈⼠，因此可以简化这个函数。所以下列代码：
`if (disabilityScheme()) doSomething`
可以变成：
`doSomething`

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
如果，规定在 “残障⼈⼠⽤电” 和 “企业⽤电” 之间只能择⼀，
那么，我们的⽅案就可以避免在 BusinessBillingScheme 中出现任何条件代码。 

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
实施本项重构时，我们希望将可能变化的部分和始终不变的部分分开，为此我们可以使⽤ Extract Method （110） 和 Decompose Conditional（238）。 
本例将对 BillingScheme 各函数实施这两项重构，直到“是否为残障⼈⼠”的所有判断都得 到了适当处理。
然后，我们再以相同过程处理其他变化情况（例如 “社会救济⽤电”）。

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;
然⽽，当我们处理第⼆种变化情况时，我们应该观察“社会救济⽤电”与“残 障⼈⼠⽤电”有何不同。
我们希望能够针对不同的变化情况建⽴起这样⼀组函数： 
它们意图相同，但针对不同的变化情况采取不同的实际⾏为。
例如上述两种变化情 况下的税额计算可能不同。
我们希望确保两个⼦类中的相应函数有相同的签名。
这可能意味我们必须修改 DisabilityBillingScheme，将这两个⼦类统⼀整理⼀番。
通常我们发现，⾯对更多变化情况时，这种相仿之中略带变化的函数模式会使 整个系统结构趋于稳定，使我们更容易添加后续更多变化情况。