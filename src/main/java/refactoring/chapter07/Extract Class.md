# 动机

你也许听过类似这样的教诲：⼀个类应该是⼀个清楚的抽象，处理⼀些明确的责任。  

但是在实际⼯作中，类会不断成⻓扩展。  
你会在这⼉加⼊⼀些功能，在那⼉加⼊⼀些数据。给某个类添加⼀项新责任时，你会觉得不值得为这项责任分离出⼀个单独的类。  
于是，随着责任不断增加，这个类会变得过分复杂。很快，你的类就 会变成⼀团乱麻。  
这样的类往往含有⼤量函数和数据。这样的类往往太⼤⽽不易理解。  
此时你需要考虑哪些部分可以分离出去，并将它们分离到⼀个单独的类中。
如果 某些数据 和 某些函数 总是 ⼀起出现，某些数据 经常同时变化甚⾄彼此相依，这就表示你应该将它们分离出去。
⼀个有⽤的测试就是问你⾃⼰，如果你搬移了某些字段和函数，会发⽣什么事？其他字段和函数是否因此变得⽆意义？

另⼀个往往在开发后期出现的信号是类的⼦类化⽅式。
如果你发现⼦类化只影响类的部分特性，或 如果你发现 某些特性 需要以⼀种⽅式来⼦类化，某些特性 则需要以另⼀种⽅式⼦类化，这就意味你需要分解原来的类。

# 做法
⼝ 决定如何分解类所负的责任。 

⼝ 建⽴⼀个新类，⽤以表现从旧类中分离出来的责任。

- 如果旧类剩下的责任与旧类名称不符，为旧类更名. 

⼝ 建⽴“从旧类访问新类”的连接关系。

- 有可能需要⼀个双向连接。但是在真正需要它之前，不要建⽴“从新类通 往旧类”的连接。

⼝ 对于你想搬移的每⼀个字段，运⽤ Move Field （146）搬移之。

⼝ 每次搬移后，编译、测试。 

⼝ 使⽤ Move Method（142）将必要函数搬移到新类。先搬移较低层函数（也就是 “被其他函数调⽤” 多于 “调⽤其他函数” 的函数），再搬移较⾼层函数。

⼝ 每次搬移之后，编译、测试。 

⼝ 检查，精简每个类的接⼝。
- 如果你建⽴起双向连接，检查是否可以将它改⼒单向连接.

⼝ 决定是否公开新类。如果你的确需要公开它，就要决定让它成为 引⽤对象 还是 不可变的值对象。