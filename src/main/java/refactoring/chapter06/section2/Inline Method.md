# Inline Method (内联函数)

一个函数的本体与名称同样清楚易懂。

在函数调用点插入函数本体，然后移除该函数。
```java
int getRating() {
    return (moreThanFiveLateDeliveries()) ? 2 : 1;
}

boolean moreThanFiveLateDeliveries() {
    return numberOfLateDeliveries > 5;
}
```

```java
int getRating() {
    return (numberOfLateDeliveries > 5) ? 2 : 1;
}

```

## 动机

本书经常以简短的函数表现动作意图，这样会使代码更清晰易读。 
但有时候，你会遇到某些函数，其内部代码和函数名称同样清晰易读。
也可能你重构了该函数，使得其内容和其名称变得同样清晰。
果真如此，你就应该去掉这个函数，直接使用其中的代码。
间接性可能带来帮助，但非必要的间接性总是让人不舒服。

另一种需要使用 Inline Method(117)的情况是：你手上有一群组织不甚合理的函数。
你可以将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。
Kent Beck发现，实施 Replace Method with Method Object (135)之前先这么做，往往可以获得不错的效果。
你可以把所要的函数(有着你要的行为)的所有调用对象的函数内容都内联到函数对象中。
比起既要移动一个函数、又要移动它所调用的其他所有函数，将整个大型函数作为整体来移动会比较简单。

如果别人使用了太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，
造成我在这些委托动作之间晕头转向，那么，我通常都会使用Inline Method(117)。
当然，间接层有其价值，但不是所有间接层都有价值。试着使用内联手法，我可以找出那些有用的间接层，同时将那些无用的间接层去除。

## 做法

-[ ] 检查函数，确定它不具多态性。

动如果子类继承了这个函数，就不要将此函数内联，因为子类无法覆写一个
根本不存在的函数。

-[ ] 找出这个函数的所有被调用点。

-[ ] 将这个函数的所有被调用点都替换为函数本体。
-[ ] 编译，测试。

-[ ] 删除该函数的定义。

被我这样一写，Inline Method(117) 似乎很简单。
但情况往往并非如此。
对于 递归调用、多返回点、内联至另一个对象中而该对象并无提供访问函数...
每一种情况我都可以写上好几页。
我之所以不写这些特殊情况，原因很简单：
如果你遇到了这样的复杂情况，那么，就不应该使用这个重构手法。




